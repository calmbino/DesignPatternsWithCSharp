# Creational Patterns(생성 패턴)

## # Intro

- 다양한 객체 생성 메커니즘을 제공하여 기존 코드의 <mark>**유연성(flexibility)**</mark>과 <mark>**재사용성(reuse)**</mark>을 높일 수 있다.
- 객체 생성 메커니즘을 제공하여 객체 생성 과정을 추상화하거나 제어한다.

## # Body

### Factory Method
- 구체적으로 어떤 객체(인스턴스)를 생성할 것인가에 대한 결정을 서브 클래스에 위임한다.
- 이해를 돕기 위한 상황 비유
  - 1) Calmbino라는 의류 브랜드를 출시한다.
  - 2) `생산라인`에 대한 `공통 규격`을 정의한다. (Creator 추상화)
  - 3) `제품`에 대한 `공통 규격`을 정의한다. (Product 추상화)
  - 4) 제품별로 공통 규격을 준수하는 `생산라인을 구축`한다. (Crator 구체화)
    - ex> 청바지 생산라인, 셔츠 생산라인, 후드티 생산라인 등등..
  - 5) 공통 규격을 준수하는 `제품을 디자인`한다. (Product 구체화)
    - ex> 청바지, 셔츠, 후드티
  - 6) 각각의 생산라인에서 공통 규격을 준수하는 `제품들을 생산`한다. (팩토리 메서드 호출)
  - 7) Calmbino 브랜드에서 모자를 새롭게 출시하고자 한다.
  - 8) 모자 생산라인을 구축하고 모자를 디자인한다.
  - 9) 기존의 생산 설비는 그대로 유지하면서 새로운 제품을 생산할 수 있게 된다.
- 객체를 생성하는 코드와 객체를 실제로 사용하는 코드를 분리함으로써, 객체 생성 코드를 독립적으로 확장하기 쉽다. 
- `단일 책임 원칙`과 `개방/폐쇄 원칙`을 준수하기 때문에 코드를 더 쉽게 관리할 수 있고, 보다 안전하게 확장해 나갈 수 있다.
- 단, 추상화 계층이 추가되고 서브 클래스들이 증가함에 따라 코드의 복잡성이 높아져 유지보수가 어려워질 수 있으니 유의한다.

### Abstract Factory
- 구체적인 클래스를 지정하지 않고도 관련 있는 `객체 그룹`을 생성할 수 있다.
- 주로 관련 있는 `객체들을 그룹화(제품군)하여 생성`할 때 사용된다.
- 팩토리를 사용하는 Client는 구체적으로 어떤 클래스(Concrete Class)가 사용되는지 모른다. 그렇기 때문에 다양한 팩토리를 인자로 받아 다형성을 통해 다양한 제품군을 유연하게 생성할 수 있다. 
  ![image](https://github.com/user-attachments/assets/2c9b92bd-103b-4b33-9f71-099f3e00eeed)

### Builder
- 복잡한 객체들을 `단계별`로 생성할 수 있다.
  - 제품이 생성되는 동안 다른 객체들이 제품에 접근(access)하는 것을 허용하지 않는다.
  - 객체를 생성하는 프로세스(과정)와 결과물(내용)을 분리함으로써, `동일한 프로세스`로도 `다양한 결과물`을 만들 수 있다.
- 생성자에 많은 매개변수가 필요하거나, 객체 생성 중에 설정해야 할 필수&선택 속성이 있을 때 유용하다.
- 빌더 패턴을 사용하면 객체를 점진적으로 설정할 수 있어 코드의 가독성이 높아지고, 불변 객체를 생성하거나 다양한 설정을 필요로 하는 객체를 유연하게 만들 수 있다.

### Prototype
- `기존 인스턴스를 복제`하여 새로운 인스턴스를 만드는 방법이다.
  - 새로운 객체를 생성하는 것보다 복제(복사)하는 것이 비용적인 측면(시간 또는 메모리)에서 효율적일 수 있다.
- 예를 들어, DB 또는 네트워크(HTTP)를 통해 가져온 객체(데이터)를 재사용할이 있을 때 복사(새로운 인스턴스 생성)해서 사용하면 보다 효율적이다.
- 또는 객체의 새로운 인스턴스를 생성하는 과정이 복잡한 경우에 대신해서 복사된 인스턴스를 사용할 수도 있다.
- 즉, 클라이언트 입장에서 봤을 때 복잡한 객체(인스턴스)를 생성하는 과정을 숨길 수 있다.

### Singleton

- `인스턴스`를 `오직 하나`만 제공하는 클래스이며, 이 인스턴스에 대한 `전역 접근(액세스) 지점`을 제공한다.
- 특정 클래스의 인스턴스를 단 하나만 생성하도록 보장하며, 해당 클래스에 접근하는 모든 클라이언트는 동일한 인스턴스를 공유한다.
  - ex) 애플리케이션의 전역 상태 관리, 공통 리소스(자원) 제어 등등
- 싱글턴 패턴의 단점 중 하나는 멀티스레드 환경에서 취약하다는 것이다. 서로 다른 스레드가 동시에 인스턴스를 생성하려고 시도할 수 있기 때문!
  - 해결책은?
    - 1) `Double-Checked Locking`을 이용한 구현
       - 메서드를 호출할 때마다 Lock을 거는게 아니라, `인스턴스 생성 시점에만 Lock`을 걸어 동시성 문제를 해결하는 것이다.
    - 2) `정적 초기화`를 이용한 방법
       - 클래스가 로드될 때 미리 인스턴스를 만들어 놓는 방법이다. `이른 초기화`를 통해
       - 그러나 인스턴스 생성 비용이 큰 경우(복잡한 절차, 큰 메모리 요구 등)에는 성능상에 손해가 있을 수 있다.
    - 3) `Lazy<T>`를 이용한 구현 ([참고](https://rito15.github.io/posts/singleton-pattern/))
      - C#의 Lazy<T>는 스레드 안전성을 보장한다. 이를 이용하여 보단 간결한 코드로 `지연 초기화`와 `스레드 안전성`을 동시 얻을 수 있다.
      - 하지만 이또한, 내부적으로 오버헤드가 발생하기 때문에 성능적인 측면에서는 손해가 있을 수 있다.
    